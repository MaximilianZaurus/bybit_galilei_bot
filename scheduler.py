import asyncio
import json
import logging
import pandas as pd
import httpx
from apscheduler.schedulers.asyncio import AsyncIOScheduler
from apscheduler.triggers.interval import IntervalTrigger
from fastapi import FastAPI

from bot import send_message       # –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏—è –≤ Telegram
from signals import analyze_signal # —Ñ—É–Ω–∫—Ü–∏—è –∞–Ω–∞–ª–∏–∑–∞ —Å–∏–≥–Ω–∞–ª–æ–≤

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

TIMEFRAME = '15'  # 15-–º–∏–Ω—É—Ç–Ω—ã–µ —Å–≤–µ—á–∏
BASE_URL = "https://api.bybit.com/v5/market/kline"

app = FastAPI()

def load_tickers():
    """–ó–∞–≥—Ä—É–∂–∞–µ—Ç —Ç–∏–∫–µ—Ä—ã –∏–∑ —Ñ–∞–π–ª–∞ tickers.json"""
    with open('tickers.json', 'r', encoding='utf-8') as f:
        return json.load(f)

async def fetch_klines(ticker: str, limit=50) -> pd.DataFrame:
    """–ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ –∑–∞–ø—Ä–∞—à–∏–≤–∞–µ—Ç —Å–≤–µ—á–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ —Å Bybit –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç DataFrame"""
    params = {
        'category': 'linear',
        'symbol': ticker,
        'interval': TIMEFRAME,
        'limit': limit
    }
    async with httpx.AsyncClient(timeout=10) as client:
        resp = await client.get(BASE_URL, params=params)
        resp.raise_for_status()
        data = resp.json()

    if data.get('retCode', 1) != 0:
        raise Exception(f"API Error for {ticker}: {data.get('retMsg')}")

    klines = data.get('result', {}).get('list', [])
    if not klines:
        raise Exception(f"No kline data returned for {ticker}")

    df = pd.DataFrame(klines)
    df.columns = ['open_time', 'open', 'high', 'low', 'close', 'volume'] + [f"extra_{i}" for i in range(len(df.columns) - 6)]
    df = df[['open_time', 'open', 'high', 'low', 'close', 'volume']]
    df['open_time'] = pd.to_datetime(df['open_time'], unit='ms')
    for col in ['open', 'high', 'low', 'close', 'volume']:
        df[col] = pd.to_numeric(df[col])
    return df

async def analyze_and_send():
    tickers = load_tickers()
    messages = []

    for ticker in tickers:
        try:
            df = await fetch_klines(ticker)
            signals = analyze_signal(df)
            d = signals['details']

            msg = (
                f"üìà <b>{ticker}</b>\n"
                f"–¶–µ–Ω–∞: {d['close']:.4f}\n"
                f"RSI: {d['rsi']:.2f} | CCI: {d['cci']:.2f} | MACD Hist: {d['macd_hist']:.4f}\n"
                f"Bollinger Bands: [{d['bb_lower']:.4f} - {d['bb_upper']:.4f}]\n"
                f"–û–±—ä—ë–º: {d['volume']:.2f} (—Å—Ä–µ–¥–Ω–∏–π: {d['volume_ma']:.2f})\n\n"
                f"–°–∏–≥–Ω–∞–ª—ã:\n"
                f"‚ñ∂Ô∏è –í—Ö–æ–¥ –≤ –õ–æ–Ω–≥: {'‚úÖ' if signals['long_entry'] else '‚ùå'}\n"
                f"‚èπ –í—ã—Ö–æ–¥ –∏–∑ –õ–æ–Ω–≥–∞: {'‚úÖ' if signals['long_exit'] else '‚ùå'}\n"
                f"‚ñ∂Ô∏è –í—Ö–æ–¥ –≤ –®–æ—Ä—Ç: {'‚úÖ' if signals['short_entry'] else '‚ùå'}\n"
                f"‚èπ –í—ã—Ö–æ–¥ –∏–∑ –®–æ—Ä—Ç–∞: {'‚úÖ' if signals['short_exit'] else '‚ùå'}\n"
            )
            messages.append(msg)
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ {ticker}: {e}")
            messages.append(f"‚ùó –û—à–∏–±–∫–∞ —Å {ticker}: {e}")

    final_message = "\n\n".join(messages)
    await send_message(final_message)

scheduler = None

def start_scheduler():
    global scheduler
    loop = asyncio.get_event_loop()
    scheduler = AsyncIOScheduler(event_loop=loop)

    async def async_job_wrapper():
        await analyze_and_send()

    def run_async_job():
        asyncio.run_coroutine_threadsafe(async_job_wrapper(), loop)

    scheduler.add_job(run_async_job, trigger=IntervalTrigger(minutes=15))
    scheduler.start()
    logger.info("Scheduler started, running every 15 minutes")

@app.on_event("startup")
async def on_startup():
    start_scheduler()
    await send_message("üöÄ –ë–æ—Ç –∑–∞–ø—É—â–µ–Ω –∏ —Ä–∞–±–æ—Ç–∞–µ—Ç. –ü–µ—Ä–≤—ã–π –∞–Ω–∞–ª–∏–∑ –±—É–¥–µ—Ç —á–µ—Ä–µ–∑ 15 –º–∏–Ω—É—Ç.")

@app.get("/")
async def root():
    return {"message": "Bot is running"}
